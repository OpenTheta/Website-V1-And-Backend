
# Code needed to interact with Blockchain

## [Metamask](https://docs.metamask.io/guide/) set up

### Connect to metamask

```javascript
// check if Metamask is installed
if (typeof window.ethereum !== 'undefined') {
    // check Network settings (see Set Theta Network)
    await this.checkNetwork()
    // get accounts (we always use account 0)
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    this.userAddress = accounts[0];
} else {
    console.log("No MetaMask available!");
}
```

### Set Theta Network

This code will check if the wallet is on the correct chain (Theta) and if not it will ask the user to switch the chain and set it up. 
```javascript
// check chain ID
let chainId = await window.ethereum.request({ method: 'eth_chainId' })
if(chainId !== "0x169") {
    // Settings for Theta Network
    const validNetworkOptions = {
      chainId: "0x169",
      chainName: "Theta Mainnet",
      nativeCurrency: { name: "Theta Fuel", symbol: "TFUEL", decimals: 18 },
      rpcUrls: ["https://eth-rpc-api.thetatoken.org/rpc"],
      blockExplorerUrls: ["https://explorer.thetatoken.org/"],
    };
    // Add the network to Metamask
    window.ethereum.request({
      method: "wallet_addEthereumChain",
      params: [validNetworkOptions],
    });
}
```

## Using [Ethers.js](https://docs.ethers.io/v5/)

### Set up Provider

This gets the provider for the Network that is set in Metamask (only possible if MetaMask is installed)
```javascript
provider  = new ethers.providers.Web3Provider(window.ethereum);
```

### Get Balance of account

This gives back the amount of TFuel that is currently in the wallet of userAddress to two decimal places
```javascript
(ethers.BigNumber.from(await provider.getBalance(userAddress)).div(ethers.BigNumber.from("10000000000000000"))).toNumber()/100;
```

### Store ABI Code

There are two ways, either you can use the ABI code that is generated by [remix](https://remix.ethereum.org), or a human readable form like this:
```javascript
const ABI_NFT = [
    "function balanceOf(address _owner) view returns (uint256)",
    "function tokenURI(uint256 _tokenId) view returns (string memory)",
    "function tokenOfOwnerByIndex(address _owner, uint256 _index) view returns (uint256)",
    "function approve(address to, uint256 tokenID)",
    "function getApproved(uint256 tokenId) view returns (address)",
    "event Approval(address indexed owner, address indexed to, uint256 tokenId)",
    "event Transfer(address indexed src, address indexed dst, uint256 tokenId)",
    "function totalSupply() view returns (uint256)",
    "function transferFrom(address from, address to, uint256 tokenId)",
    "function safeMint(address _address) payable",
    // Functions added by me into some NFT smart contracts
    "function MAX_NFT_SUPPLY() view returns (uint256)",
    "function saleIsActive() view returns (bool)",
    "function getNFTPrice() view returns (uint256)",
    "function safeMintQuantity(address to, uint8 quantity) payable"
];

const ABI_MARKET = [
    "event MarketItemCreated(uint256 indexed itemId, address indexed nftContract, uint256 indexed tokenId, address seller, address owner, string category, uint256 price, bool isSold)",
    "function createMarketItem(address nftContract, uint256 tokenId, uint256 price, string category) payable",
    "function createMarketSale(address nftContract, uint256 itemId) payable",
    "function createMarketCancel(address nftContract, uint256 itemId) payable",
    "function updateMarketItem(address nftContract, uint256 tokenId, uint256 price, uint256 itemId)",
    "function fetchCreateNFTs() view returns (tuple(uint256 itemId, address nftContract, uint256 tokenId, address seller, address owner, string category, uint256 price, bool isSold)[])",
    "function fetchPurchasedNFTs() view returns (tuple(uint256 itemId, address nftContract, uint256 tokenId, address seller, address owner, string category, uint256 price, bool isSold)[])",
    "function getItemsByCategory(string category) view returns (tuple(uint256 itemId, address nftContract, uint256 tokenId, address seller, address owner, string category, uint256 price, bool isSold)[])",
    "function getListingPrice() view returns (uint256)",
    "function getMarketItems() view returns (tuple(uint256 itemId, address nftContract, uint256 tokenId, address seller, address owner, string category, uint256 price, bool isSold)[])",
    "function getSalesFee() view returns (uint256)",
    "function getCreatorFeeBasisPoints(address NFTAddress) view returns (address, uint256)",
    "event MarketItemSale(uint256 itemId,address nftContract,uint256 tokenId,address seller,address owner,string category,uint256 price,bool isSold)"
];
```

### Buy NFT

This code shows how the buy function is called. First we need to get the signer (to read the blockchain only the 
provider is necessary but to write on the blockchain we need a signer). Next we create a contract Object, which gets the
smart contract address, ABI and signer. After, that we can call the smart contract function. If we want to send TFuel to
the contract when calling the function we use overrides and set there the value to the amount we want to send in Wei.
Finally, we can create a filter that gets a topic ([event](https://docs.ethers.io/v5/concepts/events/)), and an address to
listen to.
```javascript
// get the signer
const signer = provider.getSigner();

// set up the contract Object
const contractMarketObject = new ethers.Contract(
  marketAddress,
  ABI_MARKET,
  signer
);
// set the amount to pay
let overrides = {
value: nft.price,
};
try{
    // Try executing the smart contract function
    await contractMarketObject.createMarketSale(nft.nftContract, nft.itemId, overrides);
} catch (e) {
    return
}
// Set topic for the filter
let topic = ethers.utils.id("MarketItemSale(uint256,address,uint256,address,address,string,uint256,bool)");
// create filter with address and event topic to listen to.
let filter = {
    address: marketAddress,
    topics: [ topic ]
}

provider.on(filter, () => {
    // executed if event gets caught example loading ends
});
```

### Cancel NFT

```javascript
const signer = provider.getSigner()
const contractMarketObject = new ethers.Contract(
    marketAddress,
    ABI_MARKET,
    signer
);

await contractMarketObject.createMarketCancel(nft.nftContract, nft.itemId).catch((error) => {
    console.log(error);
});

let topic = ethers.utils.id("MarketItemSale(uint256,address,uint256,address,address,string,uint256,bool)");

let filter = {
    address: marketAddress,
    topics: [ topic ]
}

provider.on(filter, () => {
    // executed if event gets caught example loading ends
});
```

### Update NFT price

```javascript
const signer = provider.getSigner()
const contractMarketObject = new ethers.Contract(
    MARKET_ADDRESS,
    ABI_MARKET,
    signer
);
await contractMarketObject.updateMarketItem(this.nft.nftContract, tokenId, priceWei, this.nft.itemId).catch((error) => {
    console.log(error);
});

let topic = ethers.utils.id("MarketItemUpdated(uint256,address,uint256,address,address,string,uint256,bool)");

let filter = {
    address: MARKET_ADDRESS,
    topics: [ topic ]
}

provider.on(filter, () => {
    // executed if event gets caught example loading ends
});
```

### Approve NFT (Get Creator Fee Points)
```javascript
const signer = this.provider.getSigner();

// Get creators fee Points
const contractMarketObject = new ethers.Contract(
    MARKET_ADDRESS,
    ABI_MARKET,
    signer
);
contractMarketObject.getCreatorFeeBasisPoints(this.nft.nftContract).then(res => {
    this.creatorFee = res[1].toNumber()/100
})

// Approve NFT
const contractNFTObject = new ethers.Contract(
    nft.nftContract,
    ABI_NFT,
    signer
);

// Returns the account approved for tokenId token.
let address = await contractNFTObject.getApproved(this.nft.tokenId).catch((error) => {
    console.log(error);
});

// if was already approved 
if (address !== '' && MARKET_ADDRESS === address.toLowerCase()) {
    return;
}

// Approve NFT
await contractNFTObject.approve(MARKET_ADDRESS, this.nft.tokenId).catch((error) => {
    console.log(error);
});

let topic = ethers.utils.id("Approval(address,address,uint256)");

let filter = {
    address: this.nft.NFTContract,
    topics: [topic]
}

this.provider.on(filter, () => {
    // approvel was successfull, now place sell
});
```

### Sell NFT

```javascript
const signer = this.provider.getSigner()
const contractMarketObject = new ethers.Contract(
    MARKET_ADDRESS,
    ABI_MARKET,
    signer
);

let priceWei = ethers.BigNumber.from(this.price * 100).mul(ethers.BigNumber.from("10000000000000000"));

await contractMarketObject.createMarketItem(this.nft.nftContract, this.nft.tokenId, priceWei, category).catch((error) => {
    console.log(error);
});

let topic = ethers.utils.id("MarketItemCreated(uint256,address,uint256,address,address,string,uint256,bool)");

let filter = {
    address: MARKET_ADDRESS,
    topics: [topic]
}

this.provider.on(filter, () => {
    // successfully placed on Market
});
```

### Mint NFT

```javascript
// selectedAmount is the quantity of NFTs to mint at ones.
const signer = provider.getSigner();
const contractMintObject = new ethers.Contract(
    project.contract,
    ABI_NFT,
    signer
);

// get Price from ERC721 contract in Wei
let price = contractMintObject.getNFTPrice();
// set price to pay in Wei
let overrides = {
    value: price.mul(selectedAmount),
};

try{
    if(parseInt(selectedAmount) === 1) await contractMintObject.safeMint(accounts[0], overrides);
    if(parseInt(selectedAmount) > 1) await contractMintObject.safeMintQuantity(accounts[0], selectedAmount, overrides);
    // await contractMintObject.safeMint(accounts[0], overrides);
    // here we could wait till transfer event into the user wallet. Currently it justs waits for 6sec
    setTimeout(() => {
        this.loading = false;
    },6000)
} catch (e) {
    console.log(e);
}
```

```json
  {
  "name": "Name",
  "contract": "ContractToBuy",
  "imgUrl": "ProjectImageLink",
  "creator": "zenba",
  "creatorUrl": "CreatorImageLink",
  "domain": "DomainToProjectWebsiteOrTwitter",
  "TotalAmount": 111,
  //  Maximum amount to be minted on OpenTheta
  "maxMint": 111,
  //  Only needed if limited by time
  "endDate": "April 17, 2022 03:00:00",
  //  Only needed if batchMint is possible
  "batchMint": true,
  "batchSize": 50,
  //  Only needed if NFT price is attatched to dollar price
  "priceDollar": 10,
  //  Maybe add start date, so we can already upload everything, but minting is unabled at that time
  "startDate": "April 10, 2022 02:00:00",
  // Maybe add a description
  "description": "test mint her"
},
```
### Check If mintable and get Data

```javascript
// this.project is the loaded json data
this.provider  = new ethers.providers.Web3Provider(window.ethereum);
if(this.provider) {
// this.loading = true;
    const contractMintObject = new ethers.Contract(
        this.project.contract,
        ABI_NFT,
        this.provider
    );
    
    // Max_NFT_Supply is a veriable to our smart contracts specific, so I now set it manually from the JSON data
    // try{
    //   this.maxSupply = await contractMintObject.MAX_NFT_SUPPLY();
    // } catch{
      this.maxSupply = this.project.TotalAmount
    // }
    
    // total supply function returns the current supply
    contractMintObject.totalSupply().then(res => {
      this.currentSupply = res.toNumber();
      if (this.currentSupply < this.maxSupply) {
          // saleIsActive is again a function specific to our  smart contracts
        contractMintObject.saleIsActive().then(res => {
          this.saleIsActive = res;
          if(this.saleIsActive) {
              // getNFTPrice is again a function specific to our  smart contracts
              contractMintObject.getNFTPrice().then(res => {
              this.currentPrice = (ethers.BigNumber.from(res).div(ethers.BigNumber.from("1000000000000000000"))).toNumber();
            }).catch((error) => {
              console.log(error);
              // this.loading =false;
            });
          }
        }).catch((error) => {
          console.log(error);
          // this.loading =false;
        });
      } else {
        this.saleIsActive = false;
        // this.loading =false;
      }
    }).catch((error) => {
      console.log(error);
      // this.loading =false;
    });
// this.loading =false;
// this.currentSupply = await contractObject.totalSupply();
}
```

### Check if address owns one or more tokens

```javascript
// this.project is the loaded json data
let userAddress = ""
let tokenAddress = ""
let provider  = new ethers.providers.Web3Provider(window.ethereum);
if(provider) {
// this.loading = true;
    const contractNFTObject = new ethers.Contract(
        tokenAddress,
        ABI_NFT,
        this.provider
    );
    
    let balance = await contractNFTObject.balanceOf(userAddress).catch((error) => {
        console.log(error);
    });
    
    if(balance > 0) {
        // show website
    }
}
```